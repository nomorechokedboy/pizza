/* tslint:disable */
/* eslint-disable */
/**
 * web Blog
 * This is a web blog
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, {
	AxiosInstance,
	AxiosPromise,
	AxiosRequestConfig
} from 'axios'
import { Configuration } from './configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	createRequestFunction,
	serializeDataIfNeeded,
	setApiKeyToObject,
	setSearchParams,
	toPathString
} from './common'
// @ts-ignore
import { BASE_PATH, BaseAPI, RequestArgs, RequiredError } from './base'

/**
 *
 * @export
 * @interface CommonBasePaginationResponseEntitiesComment
 */
export interface CommonBasePaginationResponseEntitiesComment {
	/**
	 *
	 * @type {Array<EntitiesComment>}
	 * @memberof CommonBasePaginationResponseEntitiesComment
	 */
	items?: Array<EntitiesComment>
	/**
	 *
	 * @type {number}
	 * @memberof CommonBasePaginationResponseEntitiesComment
	 */
	page?: number
	/**
	 *
	 * @type {number}
	 * @memberof CommonBasePaginationResponseEntitiesComment
	 */
	page_size?: number
	/**
	 *
	 * @type {number}
	 * @memberof CommonBasePaginationResponseEntitiesComment
	 */
	total?: number
}
/**
 *
 * @export
 * @interface CommonBasePaginationResponseEntitiesPostResponse
 */
export interface CommonBasePaginationResponseEntitiesPostResponse {
	/**
	 *
	 * @type {Array<EntitiesPostResponse>}
	 * @memberof CommonBasePaginationResponseEntitiesPostResponse
	 */
	items?: Array<EntitiesPostResponse>
	/**
	 *
	 * @type {number}
	 * @memberof CommonBasePaginationResponseEntitiesPostResponse
	 */
	page?: number
	/**
	 *
	 * @type {number}
	 * @memberof CommonBasePaginationResponseEntitiesPostResponse
	 */
	page_size?: number
	/**
	 *
	 * @type {number}
	 * @memberof CommonBasePaginationResponseEntitiesPostResponse
	 */
	total?: number
}
/**
 *
 * @export
 * @interface EntitiesAuth
 */
export interface EntitiesAuth {
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesAuth
	 */
	refresh_token?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesAuth
	 */
	token?: string
}
/**
 *
 * @export
 * @interface EntitiesComment
 */
export interface EntitiesComment {
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesComment
	 */
	content?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesComment
	 */
	createdAt?: string
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesComment
	 */
	id?: number
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesComment
	 */
	postId?: number
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesComment
	 */
	reactionCount?: number
	/**
	 *
	 * @type {Array<EntitiesComment>}
	 * @memberof EntitiesComment
	 */
	replies?: Array<EntitiesComment>
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesComment
	 */
	updatedAt?: string
	/**
	 *
	 * @type {EntitiesUser}
	 * @memberof EntitiesComment
	 */
	user?: EntitiesUser
}
/**
 *
 * @export
 * @interface EntitiesCommentRequest
 */
export interface EntitiesCommentRequest {
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesCommentRequest
	 */
	content?: string
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesCommentRequest
	 */
	parentId?: number
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesCommentRequest
	 */
	postId?: number
}
/**
 *
 * @export
 * @interface EntitiesPost
 */
export interface EntitiesPost {
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPost
	 */
	content?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPost
	 */
	createdAt?: string
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesPost
	 */
	id?: number
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPost
	 */
	image?: string
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesPost
	 */
	parentId?: number
	/**
	 *
	 * @type {boolean}
	 * @memberof EntitiesPost
	 */
	published?: boolean
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPost
	 */
	publishedAt?: string
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesPost
	 */
	reactionCount?: number
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPost
	 */
	slug?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPost
	 */
	title?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPost
	 */
	updatedAt?: string
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesPost
	 */
	userId?: number
}
/**
 *
 * @export
 * @interface EntitiesPostRequest
 */
export interface EntitiesPostRequest {
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPostRequest
	 */
	content?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPostRequest
	 */
	image?: string
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesPostRequest
	 */
	parentId?: number
	/**
	 *
	 * @type {boolean}
	 * @memberof EntitiesPostRequest
	 */
	published?: boolean
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPostRequest
	 */
	title?: string
}
/**
 *
 * @export
 * @interface EntitiesPostResponse
 */
export interface EntitiesPostResponse {
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesPostResponse
	 */
	commentCount?: number
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPostResponse
	 */
	content?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPostResponse
	 */
	createdAt?: string
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesPostResponse
	 */
	id?: number
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPostResponse
	 */
	image?: string
	/**
	 *
	 * @type {EntitiesPost}
	 * @memberof EntitiesPostResponse
	 */
	parent?: EntitiesPost
	/**
	 *
	 * @type {boolean}
	 * @memberof EntitiesPostResponse
	 */
	published?: boolean
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPostResponse
	 */
	publishedAt?: string
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesPostResponse
	 */
	reactionCount?: number
	/**
	 *
	 * @type {Array<EntitiesReaction>}
	 * @memberof EntitiesPostResponse
	 */
	reactions?: Array<EntitiesReaction>
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPostResponse
	 */
	slug?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPostResponse
	 */
	title?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesPostResponse
	 */
	updatedAt?: string
	/**
	 *
	 * @type {EntitiesUser}
	 * @memberof EntitiesPostResponse
	 */
	user?: EntitiesUser
}
/**
 *
 * @export
 * @interface EntitiesReaction
 */
export interface EntitiesReaction {
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesReaction
	 */
	createdAt?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesReaction
	 */
	updatedAt?: string
	/**
	 *
	 * @type {EntitiesUser}
	 * @memberof EntitiesReaction
	 */
	user?: EntitiesUser
}
/**
 *
 * @export
 * @interface EntitiesSignUpBody
 */
export interface EntitiesSignUpBody {
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesSignUpBody
	 */
	email?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesSignUpBody
	 */
	fullname?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesSignUpBody
	 */
	password?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesSignUpBody
	 */
	username?: string
}
/**
 *
 * @export
 * @interface EntitiesUpdatePassword
 */
export interface EntitiesUpdatePassword {
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUpdatePassword
	 */
	newPassword?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUpdatePassword
	 */
	oldPassword?: string
}
/**
 *
 * @export
 * @interface EntitiesUser
 */
export interface EntitiesUser {
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUser
	 */
	avatar?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUser
	 */
	createdAt?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUser
	 */
	email?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUser
	 */
	fullName?: string
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesUser
	 */
	id?: number
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUser
	 */
	identifier?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUser
	 */
	phoneNumber?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUser
	 */
	updatedAt?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUser
	 */
	userName?: string
}
/**
 *
 * @export
 * @interface EntitiesUserLogin
 */
export interface EntitiesUserLogin {
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUserLogin
	 */
	identifier?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUserLogin
	 */
	password?: string
}
/**
 *
 * @export
 * @interface EntitiesUserReq
 */
export interface EntitiesUserReq {
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUserReq
	 */
	avatar?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUserReq
	 */
	email?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUserReq
	 */
	fullname?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUserReq
	 */
	phonenumber?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUserReq
	 */
	username?: string
}
/**
 *
 * @export
 * @interface EntitiesUserResponse
 */
export interface EntitiesUserResponse {
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUserResponse
	 */
	avatar?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUserResponse
	 */
	email?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUserResponse
	 */
	fullname?: string
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesUserResponse
	 */
	id?: number
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUserResponse
	 */
	phone?: string
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesUserResponse
	 */
	username?: string
}
/**
 *
 * @export
 * @interface EntitiesWriteReactionBody
 */
export interface EntitiesWriteReactionBody {
	/**
	 *
	 * @type {number}
	 * @memberof EntitiesWriteReactionBody
	 */
	reactableId: number
	/**
	 *
	 * @type {string}
	 * @memberof EntitiesWriteReactionBody
	 */
	reactableType: EntitiesWriteReactionBodyReactableTypeEnum
}

export const EntitiesWriteReactionBodyReactableTypeEnum = {
	Posts: 'posts',
	Comments: 'comments'
} as const

export type EntitiesWriteReactionBodyReactableTypeEnum =
	(typeof EntitiesWriteReactionBodyReactableTypeEnum)[keyof typeof EntitiesWriteReactionBodyReactableTypeEnum]

/**
 *
 * @export
 * @interface HandlerRefreshTokenRequest
 */
export interface HandlerRefreshTokenRequest {
	/**
	 *
	 * @type {string}
	 * @memberof HandlerRefreshTokenRequest
	 */
	refresh_token?: string
}
/**
 *
 * @export
 * @interface HandlerResetPasswordResetPasswordReq
 */
export interface HandlerResetPasswordResetPasswordReq {
	/**
	 *
	 * @type {string}
	 * @memberof HandlerResetPasswordResetPasswordReq
	 */
	password?: string
	/**
	 *
	 * @type {string}
	 * @memberof HandlerResetPasswordResetPasswordReq
	 */
	token?: string
}
/**
 *
 * @export
 * @interface HandlerUpdateCommentCommentRequest
 */
export interface HandlerUpdateCommentCommentRequest {
	/**
	 *
	 * @type {string}
	 * @memberof HandlerUpdateCommentCommentRequest
	 */
	content?: string
}
/**
 *
 * @export
 * @interface HandlerUserEmailReq
 */
export interface HandlerUserEmailReq {
	/**
	 *
	 * @type {string}
	 * @memberof HandlerUserEmailReq
	 */
	email?: string
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * send email to user for reset password
		 * @summary option when user forgot password
		 * @param {HandlerUserEmailReq} todo user email
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authForgotPasswordPost: async (
			todo: HandlerUserEmailReq,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'todo' is not null or undefined
			assertParamExists(
				'authForgotPasswordPost',
				'todo',
				todo
			)
			const localVarPath = `/auth/forgot-password`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] =
				'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				todo,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Use for login response the refresh_token and accessToken
		 * @summary User Login
		 * @param {EntitiesUserLogin} todo Login
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authLoginPost: async (
			todo: EntitiesUserLogin,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'todo' is not null or undefined
			assertParamExists('authLoginPost', 'todo', todo)
			const localVarPath = `/auth/login`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] =
				'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				todo,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Get UserInfo by accessToken
		 * @summary Get user infor by token
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authMeGet: async (
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/auth/me`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication ApiKeyAuth required
			await setApiKeyToObject(
				localVarHeaderParameter,
				'Authorization',
				configuration
			)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Create a new access token.
		 * @summary create a new access token
		 * @param {HandlerRefreshTokenRequest} request refresh_token
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authRefreshTokenPost: async (
			request: HandlerRefreshTokenRequest,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'request' is not null or undefined
			assertParamExists(
				'authRefreshTokenPost',
				'request',
				request
			)
			const localVarPath = `/auth/refresh-token`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] =
				'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				request,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Create New UserUsecase
		 * @summary Create User
		 * @param {EntitiesSignUpBody} todo New User
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authRegisterPost: async (
			todo: EntitiesSignUpBody,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'todo' is not null or undefined
			assertParamExists('authRegisterPost', 'todo', todo)
			const localVarPath = `/auth/register`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] =
				'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				todo,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * reset password by token
		 * @summary reset user password
		 * @param {HandlerResetPasswordResetPasswordReq} todo new Password
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authResetPasswordPut: async (
			todo: HandlerResetPasswordResetPasswordReq,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'todo' is not null or undefined
			assertParamExists('authResetPasswordPut', 'todo', todo)
			const localVarPath = `/auth/reset-password`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] =
				'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				todo,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Update Password
		 * @param {EntitiesUpdatePassword} todo Updated Password
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authUpdatePasswordPut: async (
			todo: EntitiesUpdatePassword,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'todo' is not null or undefined
			assertParamExists('authUpdatePasswordPut', 'todo', todo)
			const localVarPath = `/auth/update-password`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication ApiKeyAuth required
			await setApiKeyToObject(
				localVarHeaderParameter,
				'Authorization',
				configuration
			)

			localVarHeaderParameter['Content-Type'] =
				'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				todo,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		}
	}
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		AuthApiAxiosParamCreator(configuration)
	return {
		/**
		 * send email to user for reset password
		 * @summary option when user forgot password
		 * @param {HandlerUserEmailReq} todo user email
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async authForgotPasswordPost(
			todo: HandlerUserEmailReq,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.authForgotPasswordPost(
					todo,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Use for login response the refresh_token and accessToken
		 * @summary User Login
		 * @param {EntitiesUserLogin} todo Login
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async authLoginPost(
			todo: EntitiesUserLogin,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EntitiesAuth>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.authLoginPost(
					todo,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get UserInfo by accessToken
		 * @summary Get user infor by token
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async authMeGet(
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EntitiesUserResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.authMeGet(
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Create a new access token.
		 * @summary create a new access token
		 * @param {HandlerRefreshTokenRequest} request refresh_token
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async authRefreshTokenPost(
			request: HandlerRefreshTokenRequest,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EntitiesAuth>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.authRefreshTokenPost(
					request,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Create New UserUsecase
		 * @summary Create User
		 * @param {EntitiesSignUpBody} todo New User
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async authRegisterPost(
			todo: EntitiesSignUpBody,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.authRegisterPost(
					todo,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * reset password by token
		 * @summary reset user password
		 * @param {HandlerResetPasswordResetPasswordReq} todo new Password
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async authResetPasswordPut(
			todo: HandlerResetPasswordResetPasswordReq,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.authResetPasswordPut(
					todo,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Update Password
		 * @param {EntitiesUpdatePassword} todo Updated Password
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async authUpdatePasswordPut(
			todo: EntitiesUpdatePassword,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.authUpdatePasswordPut(
					todo,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		}
	}
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = AuthApiFp(configuration)
	return {
		/**
		 * send email to user for reset password
		 * @summary option when user forgot password
		 * @param {HandlerUserEmailReq} todo user email
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authForgotPasswordPost(
			todo: HandlerUserEmailReq,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.authForgotPasswordPost(todo, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Use for login response the refresh_token and accessToken
		 * @summary User Login
		 * @param {EntitiesUserLogin} todo Login
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authLoginPost(
			todo: EntitiesUserLogin,
			options?: any
		): AxiosPromise<EntitiesAuth> {
			return localVarFp
				.authLoginPost(todo, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get UserInfo by accessToken
		 * @summary Get user infor by token
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authMeGet(options?: any): AxiosPromise<EntitiesUserResponse> {
			return localVarFp
				.authMeGet(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Create a new access token.
		 * @summary create a new access token
		 * @param {HandlerRefreshTokenRequest} request refresh_token
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authRefreshTokenPost(
			request: HandlerRefreshTokenRequest,
			options?: any
		): AxiosPromise<EntitiesAuth> {
			return localVarFp
				.authRefreshTokenPost(request, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Create New UserUsecase
		 * @summary Create User
		 * @param {EntitiesSignUpBody} todo New User
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authRegisterPost(
			todo: EntitiesSignUpBody,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.authRegisterPost(todo, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * reset password by token
		 * @summary reset user password
		 * @param {HandlerResetPasswordResetPasswordReq} todo new Password
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authResetPasswordPut(
			todo: HandlerResetPasswordResetPasswordReq,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.authResetPasswordPut(todo, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Update Password
		 * @param {EntitiesUpdatePassword} todo Updated Password
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authUpdatePasswordPut(
			todo: EntitiesUpdatePassword,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.authUpdatePasswordPut(todo, options)
				.then((request) => request(axios, basePath))
		}
	}
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
	/**
	 * send email to user for reset password
	 * @summary option when user forgot password
	 * @param {HandlerUserEmailReq} todo user email
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public authForgotPasswordPost(
		todo: HandlerUserEmailReq,
		options?: AxiosRequestConfig
	) {
		return AuthApiFp(this.configuration)
			.authForgotPasswordPost(todo, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Use for login response the refresh_token and accessToken
	 * @summary User Login
	 * @param {EntitiesUserLogin} todo Login
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public authLoginPost(
		todo: EntitiesUserLogin,
		options?: AxiosRequestConfig
	) {
		return AuthApiFp(this.configuration)
			.authLoginPost(todo, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get UserInfo by accessToken
	 * @summary Get user infor by token
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public authMeGet(options?: AxiosRequestConfig) {
		return AuthApiFp(this.configuration)
			.authMeGet(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Create a new access token.
	 * @summary create a new access token
	 * @param {HandlerRefreshTokenRequest} request refresh_token
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public authRefreshTokenPost(
		request: HandlerRefreshTokenRequest,
		options?: AxiosRequestConfig
	) {
		return AuthApiFp(this.configuration)
			.authRefreshTokenPost(request, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Create New UserUsecase
	 * @summary Create User
	 * @param {EntitiesSignUpBody} todo New User
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public authRegisterPost(
		todo: EntitiesSignUpBody,
		options?: AxiosRequestConfig
	) {
		return AuthApiFp(this.configuration)
			.authRegisterPost(todo, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * reset password by token
	 * @summary reset user password
	 * @param {HandlerResetPasswordResetPasswordReq} todo new Password
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public authResetPasswordPut(
		todo: HandlerResetPasswordResetPasswordReq,
		options?: AxiosRequestConfig
	) {
		return AuthApiFp(this.configuration)
			.authResetPasswordPut(todo, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Update Password
	 * @param {EntitiesUpdatePassword} todo Updated Password
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public authUpdatePasswordPut(
		todo: EntitiesUpdatePassword,
		options?: AxiosRequestConfig
	) {
		return AuthApiFp(this.configuration)
			.authUpdatePasswordPut(todo, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * CommentsApi - axios parameter creator
 * @export
 */
export const CommentsApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * get all comments from specfied comment
		 * @summary Show all comments from comment
		 * @param {number} [userID] User ID
		 * @param {number} [postID] Post ID
		 * @param {number} [parentID] Parent ID
		 * @param {number} [page] Page
		 * @param {number} [pageSize] Page Size
		 * @param {'asc' | 'desc'} [sort] Sort direction
		 * @param {'id' | 'user_id' | 'parent_id'} [sortBy] Sort by
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		commentsGet: async (
			userID?: number,
			postID?: number,
			parentID?: number,
			page?: number,
			pageSize?: number,
			sort?: 'asc' | 'desc',
			sortBy?: 'id' | 'user_id' | 'parent_id',
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/comments/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (userID !== undefined) {
				localVarQueryParameter['userID'] = userID
			}

			if (postID !== undefined) {
				localVarQueryParameter['postID'] = postID
			}

			if (parentID !== undefined) {
				localVarQueryParameter['parentID'] = parentID
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page
			}

			if (pageSize !== undefined) {
				localVarQueryParameter['pageSize'] = pageSize
			}

			if (sort !== undefined) {
				localVarQueryParameter['sort'] = sort
			}

			if (sortBy !== undefined) {
				localVarQueryParameter['sortBy'] = sortBy
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Delete comment
		 * @summary Delete specified comment
		 * @param {number} id Comment ID
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		commentsIdDelete: async (
			id: number,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('commentsIdDelete', 'id', id)
			const localVarPath = `/comments/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication ApiKeyAuth required
			await setApiKeyToObject(
				localVarHeaderParameter,
				'Authorization',
				configuration
			)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Update comment
		 * @summary Update comment with new message
		 * @param {number} id Comment ID
		 * @param {HandlerUpdateCommentCommentRequest} comment Comment
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		commentsIdPut: async (
			id: number,
			comment: HandlerUpdateCommentCommentRequest,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('commentsIdPut', 'id', id)
			// verify required parameter 'comment' is not null or undefined
			assertParamExists('commentsIdPut', 'comment', comment)
			const localVarPath = `/comments/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication ApiKeyAuth required
			await setApiKeyToObject(
				localVarHeaderParameter,
				'Authorization',
				configuration
			)

			localVarHeaderParameter['Content-Type'] =
				'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				comment,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Create comment
		 * @summary Create comment
		 * @param {EntitiesCommentRequest} comment Comment
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		commentsPost: async (
			comment: EntitiesCommentRequest,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'comment' is not null or undefined
			assertParamExists('commentsPost', 'comment', comment)
			const localVarPath = `/comments/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication ApiKeyAuth required
			await setApiKeyToObject(
				localVarHeaderParameter,
				'Authorization',
				configuration
			)

			localVarHeaderParameter['Content-Type'] =
				'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				comment,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		}
	}
}

/**
 * CommentsApi - functional programming interface
 * @export
 */
export const CommentsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		CommentsApiAxiosParamCreator(configuration)
	return {
		/**
		 * get all comments from specfied comment
		 * @summary Show all comments from comment
		 * @param {number} [userID] User ID
		 * @param {number} [postID] Post ID
		 * @param {number} [parentID] Parent ID
		 * @param {number} [page] Page
		 * @param {number} [pageSize] Page Size
		 * @param {'asc' | 'desc'} [sort] Sort direction
		 * @param {'id' | 'user_id' | 'parent_id'} [sortBy] Sort by
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async commentsGet(
			userID?: number,
			postID?: number,
			parentID?: number,
			page?: number,
			pageSize?: number,
			sort?: 'asc' | 'desc',
			sortBy?: 'id' | 'user_id' | 'parent_id',
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CommonBasePaginationResponseEntitiesComment>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.commentsGet(
					userID,
					postID,
					parentID,
					page,
					pageSize,
					sort,
					sortBy,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Delete comment
		 * @summary Delete specified comment
		 * @param {number} id Comment ID
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async commentsIdDelete(
			id: number,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EntitiesComment>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.commentsIdDelete(
					id,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Update comment
		 * @summary Update comment with new message
		 * @param {number} id Comment ID
		 * @param {HandlerUpdateCommentCommentRequest} comment Comment
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async commentsIdPut(
			id: number,
			comment: HandlerUpdateCommentCommentRequest,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EntitiesComment>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.commentsIdPut(
					id,
					comment,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Create comment
		 * @summary Create comment
		 * @param {EntitiesCommentRequest} comment Comment
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async commentsPost(
			comment: EntitiesCommentRequest,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EntitiesComment>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.commentsPost(
					comment,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		}
	}
}

/**
 * CommentsApi - factory interface
 * @export
 */
export const CommentsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = CommentsApiFp(configuration)
	return {
		/**
		 * get all comments from specfied comment
		 * @summary Show all comments from comment
		 * @param {number} [userID] User ID
		 * @param {number} [postID] Post ID
		 * @param {number} [parentID] Parent ID
		 * @param {number} [page] Page
		 * @param {number} [pageSize] Page Size
		 * @param {'asc' | 'desc'} [sort] Sort direction
		 * @param {'id' | 'user_id' | 'parent_id'} [sortBy] Sort by
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		commentsGet(
			userID?: number,
			postID?: number,
			parentID?: number,
			page?: number,
			pageSize?: number,
			sort?: 'asc' | 'desc',
			sortBy?: 'id' | 'user_id' | 'parent_id',
			options?: any
		): AxiosPromise<CommonBasePaginationResponseEntitiesComment> {
			return localVarFp
				.commentsGet(
					userID,
					postID,
					parentID,
					page,
					pageSize,
					sort,
					sortBy,
					options
				)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Delete comment
		 * @summary Delete specified comment
		 * @param {number} id Comment ID
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		commentsIdDelete(
			id: number,
			options?: any
		): AxiosPromise<EntitiesComment> {
			return localVarFp
				.commentsIdDelete(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Update comment
		 * @summary Update comment with new message
		 * @param {number} id Comment ID
		 * @param {HandlerUpdateCommentCommentRequest} comment Comment
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		commentsIdPut(
			id: number,
			comment: HandlerUpdateCommentCommentRequest,
			options?: any
		): AxiosPromise<EntitiesComment> {
			return localVarFp
				.commentsIdPut(id, comment, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Create comment
		 * @summary Create comment
		 * @param {EntitiesCommentRequest} comment Comment
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		commentsPost(
			comment: EntitiesCommentRequest,
			options?: any
		): AxiosPromise<EntitiesComment> {
			return localVarFp
				.commentsPost(comment, options)
				.then((request) => request(axios, basePath))
		}
	}
}

/**
 * CommentsApi - object-oriented interface
 * @export
 * @class CommentsApi
 * @extends {BaseAPI}
 */
export class CommentsApi extends BaseAPI {
	/**
	 * get all comments from specfied comment
	 * @summary Show all comments from comment
	 * @param {number} [userID] User ID
	 * @param {number} [postID] Post ID
	 * @param {number} [parentID] Parent ID
	 * @param {number} [page] Page
	 * @param {number} [pageSize] Page Size
	 * @param {'asc' | 'desc'} [sort] Sort direction
	 * @param {'id' | 'user_id' | 'parent_id'} [sortBy] Sort by
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommentsApi
	 */
	public commentsGet(
		userID?: number,
		postID?: number,
		parentID?: number,
		page?: number,
		pageSize?: number,
		sort?: 'asc' | 'desc',
		sortBy?: 'id' | 'user_id' | 'parent_id',
		options?: AxiosRequestConfig
	) {
		return CommentsApiFp(this.configuration)
			.commentsGet(
				userID,
				postID,
				parentID,
				page,
				pageSize,
				sort,
				sortBy,
				options
			)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Delete comment
	 * @summary Delete specified comment
	 * @param {number} id Comment ID
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommentsApi
	 */
	public commentsIdDelete(id: number, options?: AxiosRequestConfig) {
		return CommentsApiFp(this.configuration)
			.commentsIdDelete(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Update comment
	 * @summary Update comment with new message
	 * @param {number} id Comment ID
	 * @param {HandlerUpdateCommentCommentRequest} comment Comment
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommentsApi
	 */
	public commentsIdPut(
		id: number,
		comment: HandlerUpdateCommentCommentRequest,
		options?: AxiosRequestConfig
	) {
		return CommentsApiFp(this.configuration)
			.commentsIdPut(id, comment, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Create comment
	 * @summary Create comment
	 * @param {EntitiesCommentRequest} comment Comment
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommentsApi
	 */
	public commentsPost(
		comment: EntitiesCommentRequest,
		options?: AxiosRequestConfig
	) {
		return CommentsApiFp(this.configuration)
			.commentsPost(comment, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @summary Post to save image
		 * @param {File} image upfile
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		image: async (
			image: File,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'image' is not null or undefined
			assertParamExists('image', 'image', image)
			const localVarPath = `/media/upload`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any
			const localVarFormParams = new ((configuration &&
				configuration.formDataCtor) ||
				FormData)()

			// authentication ApiKeyAuth required
			await setApiKeyToObject(
				localVarHeaderParameter,
				'Authorization',
				configuration
			)

			if (image !== undefined) {
				localVarFormParams.append('image', image as any)
			}

			localVarHeaderParameter['Content-Type'] =
				'multipart/form-data'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}
			localVarRequestOptions.data = localVarFormParams

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 *
		 * @summary get Media
		 * @param {string} uuId ID
		 * @param {string} objectName object name
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		mediaUuIdObjectNameGet: async (
			uuId: string,
			objectName: string,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'uuId' is not null or undefined
			assertParamExists(
				'mediaUuIdObjectNameGet',
				'uuId',
				uuId
			)
			// verify required parameter 'objectName' is not null or undefined
			assertParamExists(
				'mediaUuIdObjectNameGet',
				'objectName',
				objectName
			)
			const localVarPath = `/media/{uuId}/{objectName}`
				.replace(
					`{${'uuId'}}`,
					encodeURIComponent(String(uuId))
				)
				.replace(
					`{${'objectName'}}`,
					encodeURIComponent(String(objectName))
				)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		}
	}
}

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		MediaApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @summary Post to save image
		 * @param {File} image upfile
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async image(
			image: File,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.image(
					image,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @summary get Media
		 * @param {string} uuId ID
		 * @param {string} objectName object name
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async mediaUuIdObjectNameGet(
			uuId: string,
			objectName: string,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.mediaUuIdObjectNameGet(
					uuId,
					objectName,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		}
	}
}

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = MediaApiFp(configuration)
	return {
		/**
		 *
		 * @summary Post to save image
		 * @param {File} image upfile
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		image(image: File, options?: any): AxiosPromise<void> {
			return localVarFp
				.image(image, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @summary get Media
		 * @param {string} uuId ID
		 * @param {string} objectName object name
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		mediaUuIdObjectNameGet(
			uuId: string,
			objectName: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.mediaUuIdObjectNameGet(
					uuId,
					objectName,
					options
				)
				.then((request) => request(axios, basePath))
		}
	}
}

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI {
	/**
	 *
	 * @summary Post to save image
	 * @param {File} image upfile
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof MediaApi
	 */
	public image(image: File, options?: AxiosRequestConfig) {
		return MediaApiFp(this.configuration)
			.image(image, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @summary get Media
	 * @param {string} uuId ID
	 * @param {string} objectName object name
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof MediaApi
	 */
	public mediaUuIdObjectNameGet(
		uuId: string,
		objectName: string,
		options?: AxiosRequestConfig
	) {
		return MediaApiFp(this.configuration)
			.mediaUuIdObjectNameGet(uuId, objectName, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * PostsApi - axios parameter creator
 * @export
 */
export const PostsApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * get all posts
		 * @summary Show all posts
		 * @param {number} [userID] User ID
		 * @param {number} [parentID] Parent ID
		 * @param {number} [page] Page
		 * @param {number} [pageSize] Page Size
		 * @param {'asc' | 'desc'} [sort] Sort direction
		 * @param {'id' | 'title' | 'slug' | 'user_id' | 'parent_id'} [sortBy] Sort by
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsGet: async (
			userID?: number,
			parentID?: number,
			page?: number,
			pageSize?: number,
			sort?: 'asc' | 'desc',
			sortBy?:
				| 'id'
				| 'title'
				| 'slug'
				| 'user_id'
				| 'parent_id',
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/posts`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (userID !== undefined) {
				localVarQueryParameter['userID'] = userID
			}

			if (parentID !== undefined) {
				localVarQueryParameter['parentID'] = parentID
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page
			}

			if (pageSize !== undefined) {
				localVarQueryParameter['pageSize'] = pageSize
			}

			if (sort !== undefined) {
				localVarQueryParameter['sort'] = sort
			}

			if (sortBy !== undefined) {
				localVarQueryParameter['sortBy'] = sortBy
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Delete post
		 * @summary Delete specified post
		 * @param {number} id Post ID
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsIdDelete: async (
			id: number,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('postsIdDelete', 'id', id)
			const localVarPath = `/posts/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication ApiKeyAuth required
			await setApiKeyToObject(
				localVarHeaderParameter,
				'Authorization',
				configuration
			)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Update post
		 * @summary Update post with new info
		 * @param {number} id Post ID
		 * @param {EntitiesPostRequest} post Post
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsIdPut: async (
			id: number,
			post: EntitiesPostRequest,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('postsIdPut', 'id', id)
			// verify required parameter 'post' is not null or undefined
			assertParamExists('postsIdPut', 'post', post)
			const localVarPath = `/posts/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication ApiKeyAuth required
			await setApiKeyToObject(
				localVarHeaderParameter,
				'Authorization',
				configuration
			)

			localVarHeaderParameter['Content-Type'] =
				'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				post,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Create post
		 * @summary Create post
		 * @param {EntitiesPostRequest} post Post
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsPost: async (
			post: EntitiesPostRequest,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'post' is not null or undefined
			assertParamExists('postsPost', 'post', post)
			const localVarPath = `/posts/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication ApiKeyAuth required
			await setApiKeyToObject(
				localVarHeaderParameter,
				'Authorization',
				configuration
			)

			localVarHeaderParameter['Content-Type'] =
				'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				post,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Get post by slug
		 * @summary Get post
		 * @param {string} slug Post Slug
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsSlugGet: async (
			slug: string,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'slug' is not null or undefined
			assertParamExists('postsSlugGet', 'slug', slug)
			const localVarPath = `/posts/{slug}`.replace(
				`{${'slug'}}`,
				encodeURIComponent(String(slug))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Convert post to speech
		 * @summary Convert post to speech
		 * @param {string} content Content
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsT2sContentGet: async (
			content: string,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'content' is not null or undefined
			assertParamExists(
				'postsT2sContentGet',
				'content',
				content
			)
			const localVarPath = `/posts/t2s/{content}`.replace(
				`{${'content'}}`,
				encodeURIComponent(String(content))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		}
	}
}

/**
 * PostsApi - functional programming interface
 * @export
 */
export const PostsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		PostsApiAxiosParamCreator(configuration)
	return {
		/**
		 * get all posts
		 * @summary Show all posts
		 * @param {number} [userID] User ID
		 * @param {number} [parentID] Parent ID
		 * @param {number} [page] Page
		 * @param {number} [pageSize] Page Size
		 * @param {'asc' | 'desc'} [sort] Sort direction
		 * @param {'id' | 'title' | 'slug' | 'user_id' | 'parent_id'} [sortBy] Sort by
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postsGet(
			userID?: number,
			parentID?: number,
			page?: number,
			pageSize?: number,
			sort?: 'asc' | 'desc',
			sortBy?:
				| 'id'
				| 'title'
				| 'slug'
				| 'user_id'
				| 'parent_id',
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CommonBasePaginationResponseEntitiesPostResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postsGet(
					userID,
					parentID,
					page,
					pageSize,
					sort,
					sortBy,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Delete post
		 * @summary Delete specified post
		 * @param {number} id Post ID
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postsIdDelete(
			id: number,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EntitiesPostResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postsIdDelete(
					id,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Update post
		 * @summary Update post with new info
		 * @param {number} id Post ID
		 * @param {EntitiesPostRequest} post Post
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postsIdPut(
			id: number,
			post: EntitiesPostRequest,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EntitiesPostResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postsIdPut(
					id,
					post,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Create post
		 * @summary Create post
		 * @param {EntitiesPostRequest} post Post
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postsPost(
			post: EntitiesPostRequest,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EntitiesPostResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postsPost(
					post,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get post by slug
		 * @summary Get post
		 * @param {string} slug Post Slug
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postsSlugGet(
			slug: string,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EntitiesPostResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postsSlugGet(
					slug,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Convert post to speech
		 * @summary Convert post to speech
		 * @param {string} content Content
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postsT2sContentGet(
			content: string,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postsT2sContentGet(
					content,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		}
	}
}

/**
 * PostsApi - factory interface
 * @export
 */
export const PostsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = PostsApiFp(configuration)
	return {
		/**
		 * get all posts
		 * @summary Show all posts
		 * @param {number} [userID] User ID
		 * @param {number} [parentID] Parent ID
		 * @param {number} [page] Page
		 * @param {number} [pageSize] Page Size
		 * @param {'asc' | 'desc'} [sort] Sort direction
		 * @param {'id' | 'title' | 'slug' | 'user_id' | 'parent_id'} [sortBy] Sort by
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsGet(
			userID?: number,
			parentID?: number,
			page?: number,
			pageSize?: number,
			sort?: 'asc' | 'desc',
			sortBy?:
				| 'id'
				| 'title'
				| 'slug'
				| 'user_id'
				| 'parent_id',
			options?: any
		): AxiosPromise<CommonBasePaginationResponseEntitiesPostResponse> {
			return localVarFp
				.postsGet(
					userID,
					parentID,
					page,
					pageSize,
					sort,
					sortBy,
					options
				)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Delete post
		 * @summary Delete specified post
		 * @param {number} id Post ID
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsIdDelete(
			id: number,
			options?: any
		): AxiosPromise<EntitiesPostResponse> {
			return localVarFp
				.postsIdDelete(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Update post
		 * @summary Update post with new info
		 * @param {number} id Post ID
		 * @param {EntitiesPostRequest} post Post
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsIdPut(
			id: number,
			post: EntitiesPostRequest,
			options?: any
		): AxiosPromise<EntitiesPostResponse> {
			return localVarFp
				.postsIdPut(id, post, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Create post
		 * @summary Create post
		 * @param {EntitiesPostRequest} post Post
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsPost(
			post: EntitiesPostRequest,
			options?: any
		): AxiosPromise<EntitiesPostResponse> {
			return localVarFp
				.postsPost(post, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get post by slug
		 * @summary Get post
		 * @param {string} slug Post Slug
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsSlugGet(
			slug: string,
			options?: any
		): AxiosPromise<EntitiesPostResponse> {
			return localVarFp
				.postsSlugGet(slug, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Convert post to speech
		 * @summary Convert post to speech
		 * @param {string} content Content
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsT2sContentGet(
			content: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.postsT2sContentGet(content, options)
				.then((request) => request(axios, basePath))
		}
	}
}

/**
 * PostsApi - object-oriented interface
 * @export
 * @class PostsApi
 * @extends {BaseAPI}
 */
export class PostsApi extends BaseAPI {
	/**
	 * get all posts
	 * @summary Show all posts
	 * @param {number} [userID] User ID
	 * @param {number} [parentID] Parent ID
	 * @param {number} [page] Page
	 * @param {number} [pageSize] Page Size
	 * @param {'asc' | 'desc'} [sort] Sort direction
	 * @param {'id' | 'title' | 'slug' | 'user_id' | 'parent_id'} [sortBy] Sort by
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PostsApi
	 */
	public postsGet(
		userID?: number,
		parentID?: number,
		page?: number,
		pageSize?: number,
		sort?: 'asc' | 'desc',
		sortBy?: 'id' | 'title' | 'slug' | 'user_id' | 'parent_id',
		options?: AxiosRequestConfig
	) {
		return PostsApiFp(this.configuration)
			.postsGet(
				userID,
				parentID,
				page,
				pageSize,
				sort,
				sortBy,
				options
			)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Delete post
	 * @summary Delete specified post
	 * @param {number} id Post ID
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PostsApi
	 */
	public postsIdDelete(id: number, options?: AxiosRequestConfig) {
		return PostsApiFp(this.configuration)
			.postsIdDelete(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Update post
	 * @summary Update post with new info
	 * @param {number} id Post ID
	 * @param {EntitiesPostRequest} post Post
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PostsApi
	 */
	public postsIdPut(
		id: number,
		post: EntitiesPostRequest,
		options?: AxiosRequestConfig
	) {
		return PostsApiFp(this.configuration)
			.postsIdPut(id, post, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Create post
	 * @summary Create post
	 * @param {EntitiesPostRequest} post Post
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PostsApi
	 */
	public postsPost(
		post: EntitiesPostRequest,
		options?: AxiosRequestConfig
	) {
		return PostsApiFp(this.configuration)
			.postsPost(post, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get post by slug
	 * @summary Get post
	 * @param {string} slug Post Slug
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PostsApi
	 */
	public postsSlugGet(slug: string, options?: AxiosRequestConfig) {
		return PostsApiFp(this.configuration)
			.postsSlugGet(slug, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Convert post to speech
	 * @summary Convert post to speech
	 * @param {string} content Content
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PostsApi
	 */
	public postsT2sContentGet(
		content: string,
		options?: AxiosRequestConfig
	) {
		return PostsApiFp(this.configuration)
			.postsT2sContentGet(content, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * ReactionApi - axios parameter creator
 * @export
 */
export const ReactionApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Delete a reaction
		 * @summary Delete user reaction to a post
		 * @param {EntitiesWriteReactionBody} post Delete reaction body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		reactionDropDelete: async (
			post: EntitiesWriteReactionBody,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'post' is not null or undefined
			assertParamExists('reactionDropDelete', 'post', post)
			const localVarPath = `/reaction/drop`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication ApiKeyAuth required
			await setApiKeyToObject(
				localVarHeaderParameter,
				'Authorization',
				configuration
			)

			localVarHeaderParameter['Content-Type'] =
				'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				post,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Create a reaction to an article
		 * @summary React to a blog post
		 * @param {EntitiesWriteReactionBody} post Create reaction body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		reactionReactPost: async (
			post: EntitiesWriteReactionBody,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'post' is not null or undefined
			assertParamExists('reactionReactPost', 'post', post)
			const localVarPath = `/reaction/react`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication ApiKeyAuth required
			await setApiKeyToObject(
				localVarHeaderParameter,
				'Authorization',
				configuration
			)

			localVarHeaderParameter['Content-Type'] =
				'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				post,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		}
	}
}

/**
 * ReactionApi - functional programming interface
 * @export
 */
export const ReactionApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		ReactionApiAxiosParamCreator(configuration)
	return {
		/**
		 * Delete a reaction
		 * @summary Delete user reaction to a post
		 * @param {EntitiesWriteReactionBody} post Delete reaction body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async reactionDropDelete(
			post: EntitiesWriteReactionBody,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EntitiesReaction>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.reactionDropDelete(
					post,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Create a reaction to an article
		 * @summary React to a blog post
		 * @param {EntitiesWriteReactionBody} post Create reaction body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async reactionReactPost(
			post: EntitiesWriteReactionBody,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EntitiesReaction>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.reactionReactPost(
					post,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		}
	}
}

/**
 * ReactionApi - factory interface
 * @export
 */
export const ReactionApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = ReactionApiFp(configuration)
	return {
		/**
		 * Delete a reaction
		 * @summary Delete user reaction to a post
		 * @param {EntitiesWriteReactionBody} post Delete reaction body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		reactionDropDelete(
			post: EntitiesWriteReactionBody,
			options?: any
		): AxiosPromise<EntitiesReaction> {
			return localVarFp
				.reactionDropDelete(post, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Create a reaction to an article
		 * @summary React to a blog post
		 * @param {EntitiesWriteReactionBody} post Create reaction body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		reactionReactPost(
			post: EntitiesWriteReactionBody,
			options?: any
		): AxiosPromise<EntitiesReaction> {
			return localVarFp
				.reactionReactPost(post, options)
				.then((request) => request(axios, basePath))
		}
	}
}

/**
 * ReactionApi - object-oriented interface
 * @export
 * @class ReactionApi
 * @extends {BaseAPI}
 */
export class ReactionApi extends BaseAPI {
	/**
	 * Delete a reaction
	 * @summary Delete user reaction to a post
	 * @param {EntitiesWriteReactionBody} post Delete reaction body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ReactionApi
	 */
	public reactionDropDelete(
		post: EntitiesWriteReactionBody,
		options?: AxiosRequestConfig
	) {
		return ReactionApiFp(this.configuration)
			.reactionDropDelete(post, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Create a reaction to an article
	 * @summary React to a blog post
	 * @param {EntitiesWriteReactionBody} post Create reaction body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ReactionApi
	 */
	public reactionReactPost(
		post: EntitiesWriteReactionBody,
		options?: AxiosRequestConfig
	) {
		return ReactionApiFp(this.configuration)
			.reactionReactPost(post, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @summary find user profile
		 * @param {string} id User Id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userIdGet: async (
			id: string,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('userIdGet', 'id', id)
			const localVarPath = `/user/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		},
		/**
		 * Update UserInfo by Id from accessToken
		 * @summary Update user infor by token
		 * @param {EntitiesUserReq} todo Updated User
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userUpdatePut: async (
			todo: EntitiesUserReq,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'todo' is not null or undefined
			assertParamExists('userUpdatePut', 'todo', todo)
			const localVarPath = `/user/update`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(
				localVarPath,
				DUMMY_BASE_URL
			)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication ApiKeyAuth required
			await setApiKeyToObject(
				localVarHeaderParameter,
				'Authorization',
				configuration
			)

			localVarHeaderParameter['Content-Type'] =
				'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers
					? baseOptions.headers
					: {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				todo,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			}
		}
	}
}

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		UserApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @summary find user profile
		 * @param {string} id User Id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async userIdGet(
			id: string,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EntitiesUserResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.userIdGet(
					id,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Update UserInfo by Id from accessToken
		 * @summary Update user infor by token
		 * @param {EntitiesUserReq} todo Updated User
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async userUpdatePut(
			todo: EntitiesUserReq,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EntitiesUser>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.userUpdatePut(
					todo,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		}
	}
}

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = UserApiFp(configuration)
	return {
		/**
		 *
		 * @summary find user profile
		 * @param {string} id User Id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userIdGet(
			id: string,
			options?: any
		): AxiosPromise<EntitiesUserResponse> {
			return localVarFp
				.userIdGet(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Update UserInfo by Id from accessToken
		 * @summary Update user infor by token
		 * @param {EntitiesUserReq} todo Updated User
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userUpdatePut(
			todo: EntitiesUserReq,
			options?: any
		): AxiosPromise<EntitiesUser> {
			return localVarFp
				.userUpdatePut(todo, options)
				.then((request) => request(axios, basePath))
		}
	}
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
	/**
	 *
	 * @summary find user profile
	 * @param {string} id User Id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApi
	 */
	public userIdGet(id: string, options?: AxiosRequestConfig) {
		return UserApiFp(this.configuration)
			.userIdGet(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Update UserInfo by Id from accessToken
	 * @summary Update user infor by token
	 * @param {EntitiesUserReq} todo Updated User
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApi
	 */
	public userUpdatePut(
		todo: EntitiesUserReq,
		options?: AxiosRequestConfig
	) {
		return UserApiFp(this.configuration)
			.userUpdatePut(todo, options)
			.then((request) => request(this.axios, this.basePath))
	}
}
